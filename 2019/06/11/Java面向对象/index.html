<!DOCTYPE html>












  


<html class="theme-next gemini use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">






















<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">

<link rel="stylesheet" href="/css/main.css?v=7.1.2">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.1.2">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.1.2">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.1.2">


  <link rel="mask-icon" href="/images/logo.svg?v=7.1.2" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.1.2',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="Java面向对象Java面向对象—-类的构成及定义类和对象1.定义类 123456789修饰符 class 类名 &amp;#123;有参/无参构造方法成员变量方法&amp;#125;">
<meta property="og:type" content="article">
<meta property="og:title" content="Java面向对象">
<meta property="og:url" content="http://yoursite.com/2019/06/11/Java面向对象/index.html">
<meta property="og:site_name" content="Huyuanru&#39;s blog">
<meta property="og:description" content="Java面向对象Java面向对象—-类的构成及定义类和对象1.定义类 123456789修饰符 class 类名 &amp;#123;有参/无参构造方法成员变量方法&amp;#125;">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2019-06-21T06:32:21.967Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java面向对象">
<meta name="twitter:description" content="Java面向对象Java面向对象—-类的构成及定义类和对象1.定义类 123456789修饰符 class 类名 &amp;#123;有参/无参构造方法成员变量方法&amp;#125;">





  
  
  <link rel="canonical" href="http://yoursite.com/2019/06/11/Java面向对象/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Java面向对象 | Huyuanru's blog</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Huyuanru's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/11/Java面向对象/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Huyuanru">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Huyuanru's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Java面向对象

              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-06-11 15:53:12" itemprop="dateCreated datePublished" datetime="2019-06-11T15:53:12+08:00">2019-06-11</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-06-21 14:32:21" itemprop="dateModified" datetime="2019-06-21T14:32:21+08:00">2019-06-21</time>
              
            
          </span>

          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="Java面向对象"><a href="#Java面向对象" class="headerlink" title="Java面向对象"></a>Java面向对象</h1><h2 id="Java面向对象—-类的构成及定义"><a href="#Java面向对象—-类的构成及定义" class="headerlink" title="Java面向对象—-类的构成及定义"></a>Java面向对象—-类的构成及定义</h2><h3 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h3><p>1.定义类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">修饰符 <span class="class"><span class="keyword">class</span> 类名 </span>&#123;</span><br><span class="line"></span><br><span class="line">有参/无参构造方法</span><br><span class="line"></span><br><span class="line">成员变量</span><br><span class="line"></span><br><span class="line">方法</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>修饰符：public，private，abstract</p>
<p>类名：有意义的首字母大写的单词连缀</p>
<p>ps：成员之间可以相互调用，但static修饰的成员不能访问没有static修饰的成员.</p>
<p>定义构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">修饰符 类名(形参列表/可以无参)&#123;</span><br><span class="line"></span><br><span class="line">​	<span class="comment">//空或者多条执行语句</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ps：用来创建对象，系统默认给出了方法，但一旦自己写出了构造方法，系统将不再提供.</p>
<p>​    对于构造器的返回值类型，其隐式返回了当前类的对象，而不能用void。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Student</span> <span class="params">(<span class="keyword">int</span> age,<span class="keyword">int</span> hight)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">​		<span class="keyword">this</span>.age = age;</span><br><span class="line">				<span class="comment">/*此处的this是指向new出的对象的。而将形参的a的值给对象所拥有对应的属性值。所谓对象就是由类定义的一种引用数据类型*/</span></span><br><span class="line"></span><br><span class="line">​		<span class="keyword">this</span>.hight = hight;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Student in = <span class="keyword">new</span> Student(<span class="number">2</span>,<span class="number">3</span>);<span class="comment">//此处使用有参构造方法new一个对象</span></span><br></pre></td></tr></table></figure>
<p>定义成员变量：</p>
<p>修饰符 类型 变量名 初始值。</p>
<p>修饰符： public，protected，private，static，final，public，protected，private不</p>
<p>能同时使用，但可与后二者组合</p>
<p>定义方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">修饰符  返回值类型 方法名  (形参) &#123;</span><br><span class="line"></span><br><span class="line">​	<span class="comment">//方法体；</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修饰符： public，protected，private，static，final，abstract。final和abstract也</p>
<p>不能同时出现 。</p>
<p>形参列表：多组参数间“,”隔开。形参类型和形参名之间以空格隔开。</p>
<p>ps： static 修饰的变量和方法：一旦被static修饰，该方法或变量就是属于类，可用类名</p>
<p>调用。没有static修饰的只能通过对象调用。对象中改变了该变量，该变量的值会随之改变。</p>
<h2 id="Java面向对象—-成员和局部变量"><a href="#Java面向对象—-成员和局部变量" class="headerlink" title="Java面向对象—-成员和局部变量"></a>Java面向对象—-成员和局部变量</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">					   /==实例变量</span><br><span class="line"></span><br><span class="line">​			   /==成员变量 |</span><br><span class="line"></span><br><span class="line">​			|		   \==类变量（以<span class="keyword">static</span>修饰）</span><br><span class="line"></span><br><span class="line">变量分为==	        |</span><br><span class="line"></span><br><span class="line">​			|			/    ==形参</span><br><span class="line"></span><br><span class="line">​			|		      |</span><br><span class="line"></span><br><span class="line">​			   \==局部变量        |        ==方法局部变量</span><br><span class="line"></span><br><span class="line">​					      |</span><br><span class="line"></span><br><span class="line">​					  	\   ==代码块局部变量</span><br></pre></td></tr></table></figure>
<p>类变量与类共存亡，实例变量与实例共存亡。</p>
<p>调用有三种：</p>
<p>1 类.类变量</p>
<p>2 实例.实例变量</p>
<p>3 实例.类变量</p>
<p>由于类变量属于类，当实例调用了类变量并对类变量的值做出修改，就会让类变量本身发生</p>
<p>改变，其他的实例或者类本身调用时都会使用已修改的值。</p>
<p>Java允许局部变量和成员变量重名。方法的局部变量与成员变量重名时，局部变量会覆盖成</p>
<p>员变量。此时需要成员变量时需要this或者类来调用。用this是因为this会指向调用该方法</p>
<p>的实例，而实例可以调用类变量。</p>
<p><strong>在Java中还是要尽量避免重名现象。</strong></p>
<h3 id="成员变量的初始化"><a href="#成员变量的初始化" class="headerlink" title="成员变量的初始化"></a>成员变量的初始化</h3><p>加载类的同时会自动为成员变量分配内存并初始化。</p>
<p><strong>类变量和局部变量在堆内存中处于两个位置。当使用实例来访问类变量时，实际上还是由</strong></p>
<p><strong>类来访问类变量，所以对于类变量的访问尽量使用类而不是使用实例。</strong></p>
<h3 id="局部变量的初始化"><a href="#局部变量的初始化" class="headerlink" title="局部变量的初始化"></a>局部变量的初始化</h3><p>局部变量必须显式的初始化，系统在为局部变量执行赋值之前是不会为其分配内存。由于局部</p>
<p>变量不属于任何类或实例，局部变量会在栈内存中。局部变量为基本变量时，内存中会保存</p>
<p>变量的值，当其是引用型变量时，内存中会保存地址值。栈内存中的变量无需垃圾回收，执</p>
<p>行结束会自动销毁。</p>
<h3 id="变量的使用规则"><a href="#变量的使用规则" class="headerlink" title="变量的使用规则"></a>变量的使用规则</h3><p>成员变量的使用要注意，其长期存在堆内存中会是的程序开销大，同时不利于程序的内聚性。</p>
<h3 id="成员变量的选择情形："><a href="#成员变量的选择情形：" class="headerlink" title="成员变量的选择情形："></a>成员变量的选择情形：</h3><p>描述某个对象的固有信息，但其对于每个实例都有不同的值时，例如人的身高体重…，定义</p>
<p>为实例变量。</p>
<p>当某个固有信息基本不会发生改变时如人的眼睛个数，定义为类变量。</p>
<p>当某个信息需要在某个类或方法间共享，应该使用成员变量。</p>
<p><strong>局部变量出现在栈内存中，当局部变量作用范围越小，其结束的时间越早，所以尽量使用</strong></p>
<p><strong>代码块局部变量而不是方法局部变量。</strong></p>
<h2 id="Java面向对象—-方法详解"><a href="#Java面向对象—-方法详解" class="headerlink" title="Java面向对象—-方法详解"></a>Java面向对象—-方法详解</h2><h3 id="方法的所属"><a href="#方法的所属" class="headerlink" title="方法的所属"></a>方法的所属</h3><p>方法可以看作为传统意义的函数演变而来，但有着本质上区别的是，方法必须依托一个类或</p>
<p>者一个对象来定义，没有单独定义一个方法功能。但函数可以单独定义，整个软件可以由函</p>
<p>数构成。但Java中类是第一的，其包含了方法，变量，还可以创建一个实例。static修饰的</p>
<p>方法是属于类的，而未被修饰的方法只属于实例。（当涉及变量时可以看出不同。）</p>
<p>类中的方法互调有以下情形：</p>
<p>一个方法调用一个普通方法时，默认使用this所指向的对象作为调用者。</p>
<p>一个方法调用一个静态方法时，默认使用类作为调用者。这也就导致不同的对象调用static</p>
<p>修饰的方法时总是获得相同的执行结果。就是因为默认使用了类作为调用者。相反，没有</p>
<p>static修饰就会得到各不相同的结果。</p>
<h3 id="方法的传参"><a href="#方法的传参" class="headerlink" title="方法的传参"></a>方法的传参</h3><p>方法的传值是“值传递”。将实参的值传给形参，参数本身并不会改变。<strong>而这并不区分引用</strong></p>
<p><strong>类型和基本类型</strong></p>
<p>例如一个方法是将两个传进来的参数值相互交换，并且他的返回值是void型，此时打印俩个</p>
<p>实参的变量就会看到他俩的值并没有发生互换。这就是值传递的一个表现。</p>
<p>内存中的情况：</p>
<p>系统会自动为main方法分出一块栈内存，当main调用了一个互换的方法时就会再申请一块新</p>
<p>的栈内存。而两个栈内存都会出现各自的变量。因此当栈2中变量值发生交换时，栈1并没改</p>
<p>变。</p>
<h3 id="形参个数可变方法"><a href="#形参个数可变方法" class="headerlink" title="形参个数可变方法"></a>形参个数可变方法</h3><p><code>public void cha (String msg)</code>只有一个字符串参数的方法</p>
<p><code>public void cha (String... books)</code>形参个数可变的方法</p>
<p>在最后一个形参后加…    表明该形参可以传入不确定个数个参数值。多参的传入以数组形</p>
<p>式。</p>
<p><strong>想要调用形参个数可变的方法时，不能通过一个字符串来调用,会直接调用第一个方法。</strong></p>
<p><strong>传入一个字符串参数只能通过输入字符串数组。</strong></p>
<p>关于个数可变形参方法：一个方法中只能有一个，调用时可以为空，可传多个参数，可传一</p>
<p>个数组。相比于直接数组传入将会更加简洁。</p>
<p>例如：</p>
<p>test (5,”helloworld”,”你好啊”); 这是用可变形参来传入</p>
<p>test(5,new String [] {“你好啊”,”helloworld”,”我很好”}); 这是用字符串数组传入</p>
<p>**个数可变的形参只能出现在形参列表的末尾，数组形参可放在任意位置。这就导致了一个</p>
<p>方法中最多只能用一个个数可变的形参.**</p>
<h3 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h3><p>在同一个类中出现了多个同名的方法，但只需形参列表不同就可以自动识别。</p>
<p>由此Java中需要三个元素来判断一个方法</p>
<p>1：调用者，方法的所属者。可以是类可以是对象</p>
<p>2：方法名，方法的标识</p>
<p>3：形参列表，系统根据传入的实参来匹配</p>
<p><strong>返回值用于区分方法是不可行的。在Java中调用方法可以忽略返回值。此时不同的返回值</strong></p>
<p><strong>类型无法用来判断</strong></p>
<h2 id="Java面向对象—-static关键字"><a href="#Java面向对象—-static关键字" class="headerlink" title="Java面向对象—-static关键字"></a>Java面向对象—-static关键字</h2><p>static 可以修饰成员变量，可以修饰成员方法；</p>
<p>static的数据共享：</p>
<p>一个对象将其属性值改变，就会导致类变量的值发生改变。</p>
<p>成员变量：</p>
<p>static修饰的变量称为 静态变量。用static修饰的是用来共享的变量。</p>
<p>成员方法：</p>
<p>static修饰的成员方法，静态方法。既能被对象调用也能被类调用，常用类来调用。</p>
<h2 id="Java-面向对象—-关于对象"><a href="#Java-面向对象—-关于对象" class="headerlink" title="Java 面向对象—-关于对象"></a>Java 面向对象—-关于对象</h2><h3 id="对象的产生和使用"><a href="#对象的产生和使用" class="headerlink" title="对象的产生和使用"></a>对象的产生和使用</h3><p>创建对象：</p>
<p><code>Student stu = new Student();</code></p>
<p>此处的stu即为对象。未被static修饰的方法或变量只能通过对象调用,**而static修饰的既</p>
<p>可被对象调用，也可以被类调用**。</p>
<p>当调用的方法有形参时，必须为形参赋值。类和对象，类是一般的抽像的，而对象是具体的。</p>
<p>使用类创建对象,可以重复的使用一般的特征。</p>
<p>使用new创建对象，所需内存都是在堆内存中。<strong>左边的变量是一个引用型变量，其在栈内存</strong></p>
<p><strong>中指向堆内存中的对象</strong>。Student stu1 = stu；即引用型引用了一个引用型，他们都指</p>
<p>向了同一个堆内存地址。而一个对象一旦没有一个变量指向它，Java就会以垃圾处理回收内</p>
<p>存。那么把一个引用变量的值赋为null，就会让这个对象变成垃圾。</p>
<p>关于this关键字：this总是指向调用该方法的对象。</p>
<p>两种不同的引用情形：</p>
<p>1：构造方法中<strong>正在创建</strong>的对象</p>
<p>2：在方法中引用调用该方法的对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Dog&#123;</span><br><span class="line">  public void Jump（）&#123;</span><br><span class="line">    System.out.println(&quot;执行jump方法&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  public void Run()&#123;</span><br><span class="line">    this.Jump();//用this，当new一个对象时，this将会指向调用Run方法的对象</span><br><span class="line">    System.out.println(&quot;正在执行Run方法&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Java允许对象的一个成员调用另一个成员，因此上面方法前的this也可以省略static 修饰</p>
<p>的方法，可以被类或实例引用，一旦用this关键字，这个关键字可能无法指向合适的对象。</p>
<p>所以static修饰的成员不能用this引用，没有static修饰的方法只能由实例用，一旦出现在</p>
<p>static修饰的方法中，而static修饰的方法可以由类调用，这样没有static修饰的普通方法</p>
<p>就可能由类来调用，此时与第一句矛盾。所以static修饰的方法不能调用普通方法.即构成了</p>
<p>一句<em>“静态成员不能直接访问非静态成员”</em></p>
<p>static修饰的成员属于类本身，完全不属于该类实例。static修饰的成员就不应该由对象来</p>
<p>调用，应该用类来调用。</p>
<p>在静态方法中调用另一个普通方法需要创建一个对象。一般情况，普通方法访问其他方法成</p>
<p>员变量时无需使用this，但如果方法中的局部变量和成员变量重名，方法中又需要访问这个</p>
<p>成员变量就必须使用this。</p>
<p>构造器中的this指向正在初始化的对像,而构造器中访问其他成员变量和方法时可以省略this</p>
<p>关键字。但当构造方法中的变量和成员变量相同时，就可能需要this。</p>
<p><strong>将this作返回值，可连续调用相同的方法，返回了一个对象，对象可以调用方法,当调用的</strong></p>
<p><strong>方法还是该方法时就可以再返回一个对象。可以一直下去.</strong></p>
<h2 id="Java面向对象—-封装和隐藏"><a href="#Java面向对象—-封装和隐藏" class="headerlink" title="Java面向对象—-封装和隐藏"></a>Java面向对象—-封装和隐藏</h2><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>使用修饰符将对象的信息封装在对象内部，不允许<strong>直接</strong>的访问，通过<strong>类的方法</strong>来实</p>
<p>现内部信息的操作和访问。</p>
<p>其目的有如下：隐藏和封装了一些信息，例如人的眼睛个数作为一个成员变量，它不能被任</p>
<p>意修改，此时用private修饰就会保护了该信息。</p>
<h3 id="访问控制符"><a href="#访问控制符" class="headerlink" title="访问控制符"></a>访问控制符</h3><p>private–&gt;default–&gt;protected–&gt;public</p>
<p>访问级别由小到大</p>
<p><strong>private</strong></p>
<p>使用private修饰的成员变量，方法，构造方法只能在类的内部访问，通常隐藏成员变量.实</p>
<p>现了类的信息的隐藏</p>
<p><strong>default</strong></p>
<p>一个没有任何修饰符，系统使用默认的default修饰，其又称为包访问修饰符。也就是在同一</p>
<p>个包下的类都可以访问该成员。</p>
<p><strong>protected</strong></p>
<p>既可以被同包下的类访问，也可以被不同包中的子类访问。</p>
<p><strong>public</strong></p>
<p>无论访问类与被访问类是否在一个包中，或是否为父子继承关系，都可以被访问。由上可看</p>
<p>出，修饰符是用来修饰成员，因此，局部变量不可使用修饰符。外部类只能使用public和</p>
<p>default两种修饰符，其不在任何类的内部，使用其余的修饰符毫无意义。</p>
<p>Java中有一个public修饰的类时，其源文件的名称就必须与该类相同。当一public修饰的类</p>
<p>都没有时，源文件名称可以为任何合法文件名。</p>
<p>*private修饰的变量无法在其他类访问，在其他类中new一个对象，对象调用类中public修</p>
<p>饰的setter方法，setter方法中的this指向了该对象，通过方法将对象中的private修饰的</p>
<p>变量值改变了。访问控制符的使用规则*</p>
<p>绝大多数的成员变量由private修饰，一些由static修饰。</p>
<p>详见疯狂java  p134.</p>
<p>=================</p>
<h2 id="Java面向对象—-构造器"><a href="#Java面向对象—-构造器" class="headerlink" title="Java面向对象—-构造器"></a>Java面向对象—-构造器</h2><h3 id="构造器的作用"><a href="#构造器的作用" class="headerlink" title="构造器的作用"></a>构造器的作用</h3><p>首先利用构造器进行初始化，创建一个对象时，系统为这个对象的是实例变量进行默认初始</p>
<p>化。即把所有的基本类型的实例变量初始化为0，而引用型的实例变量设为null。</p>
<p>构造器会由系统自动的为其生成一个无参形式的。但程序员也可以为其自定义一个拥有形参</p>
<p>的构造器。一旦有形参的构造器被写出，系统就不会为其生成无参的构造器了。如需要无参</p>
<p>构造器，那么就需要手动的写出来。</p>
<p><strong>构造器中的关于this关键字的解释：</strong></p>
<p>系统在构造器执行之前，就已经为new出的对象分配了内存空间,而此时这块内存不能被外部</p>
<p>访问，因此构造器中只能用this关键字来访问，这就是this指向问题的解释。</p>
<h2 id="Java面向对象—-类的继承"><a href="#Java面向对象—-类的继承" class="headerlink" title="Java面向对象—-类的继承"></a>Java面向对象—-类的继承</h2><h3 id="继承的特点"><a href="#继承的特点" class="headerlink" title="继承的特点"></a>继承的特点</h3><p>继承的代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">修饰符 class SubClass extends SuperClass</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	//类定义部分</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>子类不能继承父类的构造器，但子类可以调用父类的构造方法。</p>
<p>每个类都最多只有一个直接父类</p>
<p>java.lang.Object类是所有类的父类</p>
<h3 id="重写父类的方法"><a href="#重写父类的方法" class="headerlink" title="重写父类的方法"></a>重写父类的方法</h3><p>多数情况，子类都是为了继承父类的变量或方法，但有些子类需要对方法做出一定修改。比</p>
<p>如鸵鸟继承了鸟这个类，但它没有飞的这个方法，需要做出一定修改。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Bird&#123;</span><br><span class="line">  public void fly&#123;</span><br><span class="line">    System.out.println(&quot;i can fly&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Ostrich extends Bird&#123;</span><br><span class="line">  public void fly &#123;</span><br><span class="line">    System.out.println(&quot;i can run&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这就是方法的重写，也是方法覆盖。</p>
<p><strong>方法覆盖的原则</strong> ——————两同两小一大</p>
<p>两同:方法名相同，形参列表相同</p>
<p>两小:子类方法返回值类型比父类的小或相同，子类方法声明抛出异常类应比父类的小或相等</p>
<p>一大:子类的访问权限应比父类的访问权限更大或相等</p>
<p><strong>覆盖的方法要么都是实例方法要么都是类方法。不能相混。</strong></p>
<p>子类的对象无法再访问父类中被覆盖的方法，但在子类的方法中可以使用super或者父类的类</p>
<p>名来调用父类的方法。然而对于private修饰的方法，只保存在类的内部，子类是无法访问的</p>
<p>。因此private修饰的方法不会被覆写，不存在覆盖。即使完全符合覆盖原则。</p>
<p>关于方法的重载和方法的重写：</p>
<p>方法的重载是指在一个类中，具有相同方法名和不相同形参列表的方法会出现重载。</p>
<p>方法的重写是指在父类和子间，子类以两同两小一大原则重写了父类的方法。当然子类和父</p>
<p>类之间也可以出现重载，子类继承了父类的方法，此时只要符合重载的原则就行了。</p>
<p><strong>super</strong></p>
<p>限定该对象调用它从父类继承得到的实例变量或方法。super和this 一样不能出现在static</p>
<p>修饰中的方法。super是指向其父类的，其限定为对象来调用。而static 修饰可以用类来调</p>
<p>用，此时super 的限定就没有意义。</p>
<p>除了方法，实例变量一样可能被隐藏。同名的实例变量会使子类中隐藏父类的同名变量，同</p>
<p>样需要super来调用。</p>
<p>在方法中访问一个名为a的变量，Java访问的顺序依次是</p>
<p>首先查找局部变量中是否出现a；</p>
<p>其次查找成员变量是否包含a；</p>
<p>最后在该类的直接父类查找a，依此上溯到java.lang.Object如果没有就出现编译错误</p>
<p>在Java中new一个对象会为子类所有父类的实例变量和自己拥有的实例变量自动申请内存，无</p>
<p>论是否有同名的。</p>
<p>构造器的调用</p>
<p>使用super来调用父类的构造器。要求是<strong>必须出现在子类构造器的第一行。</strong></p>
<p>关于父类构造器是一定会调用，只是分隐式和显式以及调用的顺序</p>
<p>1:子类第一行使用了super，此时为显式调用。系统直接super调用父类构造器</p>
<p>2 :子类第一行使用了this调用子类中其他构造器，此时先由系统根据this传入的实参列表</p>
<p>   调用另一个构造器，而执行本类中另一个构造器时，也会调用父类的构造器。</p>
<p>3: 子类没有this和super 会在执行子类构造器之前隐式调用父类<strong>无参</strong>构造器。</p>
<h3 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(待转换类型)待转换对象</span><br></pre></td></tr></table></figure>
<p>将一种类型的对象强制转换为另一种类型对象，是为了解决当出现多态的情况时，对象在编</p>
<p>译阶段也可以本应只能在运行阶使用的方法。</p>
<p>而将子类的对象付给父类的引用变量时，就会产生<strong>向上转型</strong>但将父类对象赋给子类时就</p>
<p>必须使用强制转换。这就出现了一种保障强转安全的instanceof的强转运算符</p>
<p>A instanceof B   通常A是一个引用型变量，B是一个类或者一个接口</p>
<p>需要注意的是:</p>
<p>1：它的返回值是boolean型，返回前面的引用型变量是否是后面的类或子类，实现类的实例。</p>
<p>2：前面操作数编译时的类型必须与后面类相同，要么是后面类的子类否则会出现编译错误。</p>
<p>由于以上特性，instanceof在放在强制转换之前可以判断前面的引用型是否为后面的对象，</p>
<p>以此提高代码的健壮性.</p>
<h2 id="Java面向对象—-多态"><a href="#Java面向对象—-多态" class="headerlink" title="Java面向对象—-多态"></a>Java面向对象—-多态</h2><h3 id="多态性"><a href="#多态性" class="headerlink" title="多态性"></a>多态性</h3><p>Java的引用型变量有两个类型：一个是编译时类型，一个是运行时类型。</p>
<p>编译时的类型由声明变量时使用的类型决定，运行时类型由实际赋予变量的对象来决定。简</p>
<p>言之就是当把一个子类的对象赋给由父类的引用型变量，在编译的时候其为父类的类型，但</p>
<p>当其运行的时候使用的是子类的类型。而此对象调用方法时总会调用子类的方法，不是父类。</p>
<p>这就出现了一种相同的类型变量调用同一个方法时有着不同的方法特征。这就是多态。</p>
<p><strong>实例变量不具备这一特性。</strong></p>
<p>##引用变量的强制转换</p>
<p>由于引用型变量无法在编译时调用其运行时的方法，此时需要用到强制类型转换，将其转换</p>
<p>为运行时的类型。（待转换类型 ） 待转换变量 。<strong>转换符除了可以将基本类型转换为另</strong></p>
<p><strong>一个类型还可以将</strong></p>
<p><strong>引用型转换成子类型。</strong></p>
<p>注意两点：</p>
<p>基本类型的转换只能在数值之间，数值和布尔之间不能转换。</p>
<p><strong>引用类型的转换，只能在继承关系之间进行。将一个父类转换成子类时，该对象必须时子</strong></p>
<p><strong>类的实例，否则会出现ClassCastException的异常。</strong></p>
<h3 id="多态的利处"><a href="#多态的利处" class="headerlink" title="多态的利处"></a>多态的利处</h3><p>当一个父类有多种子类，每个子类都需要调用一个操作类中的方法，方法传入的参数为调用</p>
<p>的对象，那么每当有一个新的子类被创建，当它调用该方法时都需要在操作类中重载该方法，</p>
<p>这样使得代码冗余，但利用多态让子类对象在执行时使用的是子类方法，编译的是父类类型，</p>
<p>将其传入方法的形参，以多态的形式减少了代码的重复。具体如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String cprolor ;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Animal</span><span class="params">(String color,<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.color = color;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnimalOperate</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Ao</span><span class="params">(Cat c)</span></span>&#123;</span><br><span class="line">        c.eat();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        sout(<span class="string">"cat likes fish"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> class <span class="title">Test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Cat c = <span class="keyword">new</span> Cat();</span><br><span class="line">        Animaloperate ao = <span class="keyword">new</span> Animaloperate;</span><br><span class="line">        ao.Ao(c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//可以看出当猫的对象被用来当参数传入Ao方法中时，就需要在Ao类中写一个猫的方法，如</span></span><br><span class="line"></span><br><span class="line">果有个狗类就需要写狗，但是利用多态Animal c = <span class="keyword">new</span> Cat();</span><br><span class="line"></span><br><span class="line">把方法改为</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Ao</span> <span class="params">(Animal c )</span></span>&#123;</span><br><span class="line">    c.eat();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*在编译时使用的是Animal类，可以作为传入参数。但当其执行的时候就会使用cat</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">类的方法，这样利用了多态和方法的重写。提高代码的复用*/</span></span><br></pre></td></tr></table></figure>
<h3 id="多态的弊端"><a href="#多态的弊端" class="headerlink" title="多态的弊端"></a>多态的弊端</h3><p>不能使用子类特有的功能。</p>
<p>此时就要使用向下转型。或者强制类型转换和—“instanceof”</p>
<p>向下转型就是将父类的引用型变量强转为子类并赋给一个子类的引用型变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Animal a = <span class="keyword">new</span> Cat();</span><br><span class="line"></span><br><span class="line">Cat c = (Cat)a;</span><br></pre></td></tr></table></figure>
<p>此时的c既可以调用子类的方法，也可以调用父类的方法。</p>
<h3 id="初始化块"><a href="#初始化块" class="headerlink" title="初始化块"></a>初始化块</h3><p>初始化块时Java类的构成的第四个成员。（包括成员变量，方法，构造器）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">初始化块的格式：</span><br><span class="line"></span><br><span class="line">修饰符 &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>初始化块的修饰符只能是static，static修饰的是静态初始化块。初始化块不能用类，对象</p>
<p>来调用，不接受任何参数的传入，只能由系统在执行构造器之前执行。static修饰的初始化</p>
<p>块成为类初始化块。类初始化块是对类进行初始化，通常用于对类成员变量执行初始化处理。</p>
<p>非静态初始化块是对实例变量进行初始化。</p>
<h1 id="未完待续"><a href="#未完待续" class="headerlink" title="未完待续"></a>未完待续</h1><h2 id="装箱小知识："><a href="#装箱小知识：" class="headerlink" title="装箱小知识："></a>装箱小知识：</h2><p>Integer包装类在装箱时，系统预设把-128到127间的数以数组形式被装缓存起来，包装时指</p>
<p>向数组首地址并以索引来查找，但当数值大于127时就会另外申请内存并指向它,因此只要大</p>
<p>于127就会指向不同的地址，两个引用型的包装类比较时是比  较地址值，因此两个不等。</p>
<p>处理对象:</p>
<p>打印对象和toString方法</p>
<p>将一个引用型变量直接打印会显示出他的地址值。而用toString这个特殊的方法可以将对象</p>
<p>一字符串的形式输出。</p>
<p>==和equalas方法</p>
<p>==以及equals都用着相同的比较方式，当==两边是数值型的时候，直接以数值进行比较。当</p>
<p>两边是引用型的时</p>
<p>候，比较在内存中的地址值.</p>
<p>一个需要注意的是：</p>
<p>Strings s = “hello”；和String s = new String（“hello“）；是有区别的</p>
<p>直接赋值 常量系统会在常量池中直接搜索，也就是第一种只会有一个对象:而第二种系统会</p>
<p>先将常量池中的hello保存，再用new创建一个String对象去引用它，也就是出现了两个字符</p>
<p>串对象所以当两个引用型变量使用常量直接赋值时，使用==会返回true,但是使用new的时候,</p>
<p>由于新出来的两个对象的地址值比不相同,因此会返回false.equals由于其特殊的比较方式，</p>
<p>只比较两个字符串的值，因此依旧返回ture</p>
<p>关于equals的重写因当满足以下条件。</p>
<p>1：自反性 任意的x，x.equals(x),返回一定要是true</p>
<p>2：对称性 任意x.equals(y);为true的话，y.equals(x);也为true</p>
<p>3：传递性 xyz三个值之间，若xy为true，yz为true则xz也为true</p>
<p>4：一致性 调用的次数不对调用的结果产生影响</p>
<p>5：任何不是null的x，x.equals(null)都要返回false</p>
<h2 id="Java面向对象—-final"><a href="#Java面向对象—-final" class="headerlink" title="Java面向对象—-final"></a>Java面向对象—-final</h2><p><strong>final修饰符</strong></p>
<p>final修饰的实例或类变量必须要程序员为其显式的指定初始值。</p>
<p>（成员变量系统会为其自动初始化，如果不显示初始化就会变成无用的变量）</p>
<p>类变量：必须在初始化块中指定初始值，或者在声明该变量时指定初始值</p>
<p>实例变量：必须在非静态初始化块中指定初始值。或者在声明该变量或构造器中指定初始值</p>
<p>实例变量不在静态初始化块中指定初始值，因为静态初始化块是静态成员，实例变量是非静</p>
<p>态成员变量。静态不能访问非静态。类成员变量不能在非静态初始化块是因为，类变量是在</p>
<p>类的初始化时就初始化了，普通初始化块无法为其重新赋值。</p>
<p><strong>final修饰的成员变量在显式初始化之前不能直接访问，但可以通过方法来访问是可以的。</strong></p>
<p>final修饰变量：变量名大写，多个字母要被下划线隔开。</p>
<p>final的局部变量：修饰形参时不能传值，修饰方法或代码块中的变量不能二次赋值</p>
<p>final修饰引用型变量：由于引用型变量是指向一个地址值,但地址值的内容可以改变，因此</p>
<p>引用型变量可改变。</p>
<p>final的宏变量。由于被final修饰后无法再改变，因此java对于一些没有调用方法，没有访</p>
<p>问普通变量的final修饰的表达式默认的识别为宏。但是例如final String a = “你好啊”+</p>
<p>String.valueOf(99) ;在这个表达式调用valueOf方法，系统就不会将其判断为宏变量。</p>
<p>final修饰的实例变量有三个位置赋值,但如果想要获得宏变量的效果，就必须在定义时的位</p>
<p>置给他赋值。</p>
<p>final修饰的方法：如果不希望子类修改父类的方法，可以使用final修饰。</p>
<p>final类：这个类是一个最终类，不能被继承。</p>
<h2 id="Java面向对象—-抽象类"><a href="#Java面向对象—-抽象类" class="headerlink" title="Java面向对象—-抽象类"></a>Java面向对象—-抽象类</h2><p>在父类中的一个方法，对于子类要调用这个方法，但是又需要对这个方法进行重写，此时在</p>
<p>父类中先定义一个方法名但没有方法体的方法，让子类自行去实现这个方法，这就是抽象类。</p>
<p>出现的原因：当子类需要调用父类的方法，但通过父类重载来给出一个是让父类的代码过于</p>
<p>庞大，一个是无法准确判断子类需要的方法。</p>
<p><strong>抽象类无法new，必须abstract，其构造器不是用来创建对象，主要用来被子类调用.含抽</strong></p>
<p><strong>象方法的类只能被定义为抽象类</strong></p>
<h2 id="Java面向对象—-接口"><a href="#Java面向对象—-接口" class="headerlink" title="Java面向对象—-接口"></a>Java面向对象—-接口</h2><h3 id="接口的定义及作用"><a href="#接口的定义及作用" class="headerlink" title="接口的定义及作用"></a>接口的定义及作用</h3><p>作用：<br>     定义变量<br>     调用其他接口中的定义的常量<br>     被其他类实现<br>定义：</p>
<p>使用interface关键字具体格式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;修饰符&#125; <span class="class"><span class="keyword">interface</span> 接口名 <span class="keyword">extends</span> 父接口1，父接口2...</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">        常量：</span><br><span class="line">        变量：成员变量只能是静态的</span><br><span class="line">        方法：默认方法。实例方法，类方法，私有方法</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>接口的变量常量与修饰符</strong></p>
<p>静态常量：系统会自动为其加上static和final修饰符。接口中定义成员变量时，总会用</p>
<p>publicstatic final修饰符，由于没有构造器和初始化块因此只能在定义时为其指定初始值</p>
<p>例如：int max = 140;是等价于 Public static final int max = 140;</p>
<p>接口内变量特征：可以在同包下的其他类中调用(public,)可以被接口直接调用（static），</p>
<p>不能在接口外二次赋值（final）。</p>
<p><strong>接口内的方法与修饰符</strong></p>
<p>默认方法必须用default修饰.除此之外系统还会用public默认修饰。私有方法的作用是提供</p>
<p>工具方法.其不能使用default修饰。但可以用static修饰。即私有方法可以是实例方法也可</p>
<p>以是类方法。如果没有指定其为何种类型的普通方法，默认是abstract修饰，普通方法不能</p>
<p>有具体方法体，但其他类型必须要有方法体。因为默认方法没用使用static修饰，所以不能</p>
<p>使用接口直接调用，只能通过接口的类的实例来调用。关于类方法，需要使用static修饰，</p>
<p>而不能使用default。类方法也是默认补充public修饰。</p>
<h3 id="接口的继承及使用"><a href="#接口的继承及使用" class="headerlink" title="接口的继承及使用"></a>接口的继承及使用</h3><p>接口支持多继承。相同的是子接口会继承父接口所有的抽象方法和常量。多个父接口以逗号</p>
<p>分开在extends后实现使用impements关键字。</p>
<p>类实现接口格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[修饰符] <span class="class"><span class="keyword">class</span> 类名 <span class="keyword">extends</span> 父类 <span class="keyword">implements</span> 接口1，接口2...</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">        类体；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个类implements的接口中必须完全诗实现接口定义的全部抽象方法。否则，该类将保留从</p>
<p>父接口那里及继承到的抽象方法该类也必须定义为抽像类。</p>
<h2 id="Java面向对象—-内部类"><a href="#Java面向对象—-内部类" class="headerlink" title="Java面向对象—-内部类"></a>Java面向对象—-内部类</h2><h3 id="定义与作用"><a href="#定义与作用" class="headerlink" title="定义与作用"></a>定义与作用</h3><p>格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">修饰符 <span class="class"><span class="keyword">class</span> 类名 ()</span>&#123;<span class="comment">//内部类的修饰符：由于内部类是一种类成员，所以修饰符会更多。</span></span><br><span class="line">    类成员</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在类的内部定义一个类，这个类离开了外部类就没有意义，这个类就是内部类。</p>
<p>遵守以下原则：</p>
<p>1：提供更好的封装，同包内不允许其他类访问。</p>
<p>2：内部类可以直接访问外部类的方法或变量。但是外部类不能访问内部类的实现细节，例如</p>
<p>内部类的成员变量。</p>
<p>3：当某些内部类只用到一次就不再使用，这个类可以不为其命名，即匿名类。</p>
<p>4：修饰符：内部类的修饰符可以有private，static，protected，public。而外部类不能</p>
<p>使用这个修饰符。</p>
<p>5：非静态内部类不能拥有静态成员</p>
<p>内部类定义只需在类的内部，其中方法中的内部类称为局部内部类。</p>
<p>局部内部类与匿名内部类不能看作类成员，只有普通内部类可以。</p>
<h3 id="关于静态内部类和非静态内部类"><a href="#关于静态内部类和非静态内部类" class="headerlink" title="关于静态内部类和非静态内部类"></a>关于静态内部类和非静态内部类</h3><p><strong>非静态内部类</strong>：</p>
<p>没有static修饰的内部类，作为外部类的一个成员，它的修饰符可以private，protected，</p>
<p>public。因为它的作用范围是在类的内部，包的内部和任意位置。</p>
<p>对于非静态内部的对象在内存中保存了一个他寄生的外部类的对象的引用。（调用非静态内</p>
<p>部类的方法时必须有一个非静态内部类的对象，在此之前必然要寄生在一个外部类实例里）</p>
<p>对于内部类中的变量:</p>
<p>当外部类成员变量，内部类成员变量和内部类方法的局部变量重名需使用this或外部类</p>
<p>名.this.varname 来区分。</p>
<p>由于内部类时外部类的一个成员，因此它可以直接调用外部类中的private修饰的变量。但</p>
<p>是反过来就不成立。外部类调用非静态内部类中的成员就必须要new一个内部类的实例。至</p>
<p>于外部类不能直接访问非静态内部类的成员，在外部类初始化完成时，非静态内部类的实例</p>
<p>不一定存在，会引起编译报错非静态内部类的对象一定包含一个外部类的引用行变量，其必</p>
<p>须寄生在外部类中，而外部类对象不一定寄生着一个内部类。非静态内部类不能包含静态成</p>
<p>员变量，静态成员方法，静态初始化块</p>
<p><strong>静态内部类</strong></p>
<p>静态内部类时属于外部类的本身，不是外部类的成员，也叫类内部类。静态内部类只能访问</p>
<p>外部类的类成员，实例成员同样不能访问。（静态不能访问非静态）静态内部类的实例方法</p>
<p>也不能使用外部类的成员，因为静态内部类寄生在外部类的本身，所以静态内部类只持有了</p>
<p>外部类的类的引用，而不是实例的引用，所以直接调用可能会出现没有外部类实例的情况，</p>
<p>所以不能访问。但外部类中的方法，初始化块都可用静态内部类创建对象和定义变量。外部</p>
<p>类不能直接访问静态内部类的成员，需要通过创建对象调用内部类的<strong>实例成员</strong>或者用类</p>
<p>名来调用<strong>类成员</strong>。接口也可以拥有内部类，接口内部的类默认由public static修饰（省</p>
<p>略时默认public,自定义只能使用public）。</p>
<p><strong>使用内部类</strong>:</p>
<p>分为三大情况：</p>
<p>1 在外部类内使用内部类不要在外部类的静态成员（静态方法，静态初始化块）使用非静态</p>
<p>内部</p>
<p>类。</p>
<p>2 在外部类外使用非静态内部类</p>
<h2 id="Java面向对象—-匿名内部类"><a href="#Java面向对象—-匿名内部类" class="headerlink" title="Java面向对象—-匿名内部类"></a>Java面向对象—-匿名内部类</h2><p>首先，它是一种内部类，一般只有当内部类需要多次重复使用的时候，可以将其创建一个内</p>
<p>部类。如果只需要使用一次就不再使用，此时就可以用匿名内部类：</p>
<p>首先不能被abstrac修饰，因为它创建后必须马上生成对象，如果使用abstract修饰就意味</p>
<p>着不能立即创建对象，故匿名内部类不能使用abstract。</p>
<p>第二不能定义构造器，因为它没有类名，但可以使用初始化块来初始化一些成员。</p>
<p>匿名内部类不需要class关键字，具体格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> 实现接口（）| 父类构造器（实参列表）&#123;</span><br><span class="line"></span><br><span class="line">​		<span class="comment">//匿名内部类的类体部分。</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由上可知匿名内部类必须实现一个接口或继承一个父类并且完全实现接口或父类中的抽象方</p>
<p>法。匿名内部类是一次性的不能重复使用的，因此可以使用一个其继承的父类的子类对象或</p>
<p>者实现的接口的子类的引用型变量来接受这个对象。</p>
<p>内部类的形参列表是跟随其继承的父类的参数列表而定的。</p>
<p>匿名内部类调用方法就是在后面直接加<code>.方法名（）</code></p>
<h2 id="Java面向对象—-Lambda-表达式："><a href="#Java面向对象—-Lambda-表达式：" class="headerlink" title="Java面向对象—-Lambda 表达式："></a>Java面向对象—-Lambda 表达式：</h2><p>紧随着匿名内部类的就是lambda表达式，是对匿名内部类的简化。</p>

      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/05/22/ssh连接github步骤/" rel="next" title="ssh连接github步骤">
                <i class="fa fa-chevron-left"></i> ssh连接github步骤
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/06/17/Java异常/" rel="prev" title="Java异常">
                Java异常 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Huyuanru</p>
              <div class="site-description motion-element" itemprop="description"></div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">8</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                    
                      
                    
                    <span class="site-state-item-count">1</span>
                    <span class="site-state-item-name">标签</span>
                  
                </div>
              
            </nav>
          

          

          

          

          

          
          

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Java面向对象"><span class="nav-number">1.</span> <span class="nav-text">Java面向对象</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Java面向对象—-类的构成及定义"><span class="nav-number">1.1.</span> <span class="nav-text">Java面向对象—-类的构成及定义</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#类和对象"><span class="nav-number">1.1.1.</span> <span class="nav-text">类和对象</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java面向对象—-成员和局部变量"><span class="nav-number">1.2.</span> <span class="nav-text">Java面向对象—-成员和局部变量</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#成员变量的初始化"><span class="nav-number">1.2.1.</span> <span class="nav-text">成员变量的初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#局部变量的初始化"><span class="nav-number">1.2.2.</span> <span class="nav-text">局部变量的初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#变量的使用规则"><span class="nav-number">1.2.3.</span> <span class="nav-text">变量的使用规则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#成员变量的选择情形："><span class="nav-number">1.2.4.</span> <span class="nav-text">成员变量的选择情形：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java面向对象—-方法详解"><span class="nav-number">1.3.</span> <span class="nav-text">Java面向对象—-方法详解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法的所属"><span class="nav-number">1.3.1.</span> <span class="nav-text">方法的所属</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#方法的传参"><span class="nav-number">1.3.2.</span> <span class="nav-text">方法的传参</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#形参个数可变方法"><span class="nav-number">1.3.3.</span> <span class="nav-text">形参个数可变方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#方法重载"><span class="nav-number">1.3.4.</span> <span class="nav-text">方法重载</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java面向对象—-static关键字"><span class="nav-number">1.4.</span> <span class="nav-text">Java面向对象—-static关键字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java-面向对象—-关于对象"><span class="nav-number">1.5.</span> <span class="nav-text">Java 面向对象—-关于对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#对象的产生和使用"><span class="nav-number">1.5.1.</span> <span class="nav-text">对象的产生和使用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java面向对象—-封装和隐藏"><span class="nav-number">1.6.</span> <span class="nav-text">Java面向对象—-封装和隐藏</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#封装"><span class="nav-number">1.6.1.</span> <span class="nav-text">封装</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#访问控制符"><span class="nav-number">1.6.2.</span> <span class="nav-text">访问控制符</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java面向对象—-构造器"><span class="nav-number">1.7.</span> <span class="nav-text">Java面向对象—-构造器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#构造器的作用"><span class="nav-number">1.7.1.</span> <span class="nav-text">构造器的作用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java面向对象—-类的继承"><span class="nav-number">1.8.</span> <span class="nav-text">Java面向对象—-类的继承</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#继承的特点"><span class="nav-number">1.8.1.</span> <span class="nav-text">继承的特点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#重写父类的方法"><span class="nav-number">1.8.2.</span> <span class="nav-text">重写父类的方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#强制类型转换"><span class="nav-number">1.8.3.</span> <span class="nav-text">强制类型转换</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java面向对象—-多态"><span class="nav-number">1.9.</span> <span class="nav-text">Java面向对象—-多态</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#多态性"><span class="nav-number">1.9.1.</span> <span class="nav-text">多态性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#多态的利处"><span class="nav-number">1.9.2.</span> <span class="nav-text">多态的利处</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#多态的弊端"><span class="nav-number">1.9.3.</span> <span class="nav-text">多态的弊端</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#初始化块"><span class="nav-number">1.9.4.</span> <span class="nav-text">初始化块</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#未完待续"><span class="nav-number">2.</span> <span class="nav-text">未完待续</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#装箱小知识："><span class="nav-number">2.1.</span> <span class="nav-text">装箱小知识：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java面向对象—-final"><span class="nav-number">2.2.</span> <span class="nav-text">Java面向对象—-final</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java面向对象—-抽象类"><span class="nav-number">2.3.</span> <span class="nav-text">Java面向对象—-抽象类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java面向对象—-接口"><span class="nav-number">2.4.</span> <span class="nav-text">Java面向对象—-接口</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#接口的定义及作用"><span class="nav-number">2.4.1.</span> <span class="nav-text">接口的定义及作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#接口的继承及使用"><span class="nav-number">2.4.2.</span> <span class="nav-text">接口的继承及使用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java面向对象—-内部类"><span class="nav-number">2.5.</span> <span class="nav-text">Java面向对象—-内部类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#定义与作用"><span class="nav-number">2.5.1.</span> <span class="nav-text">定义与作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#关于静态内部类和非静态内部类"><span class="nav-number">2.5.2.</span> <span class="nav-text">关于静态内部类和非静态内部类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java面向对象—-匿名内部类"><span class="nav-number">2.6.</span> <span class="nav-text">Java面向对象—-匿名内部类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java面向对象—-Lambda-表达式："><span class="nav-number">2.7.</span> <span class="nav-text">Java面向对象—-Lambda 表达式：</span></a></li></ol></li></ol></div>
            

	<div>
	<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=1344368486&auto=1&height=66"></iframe>
	</div>

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Huyuanru</span>

  

  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.1.2</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=3.4.1"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/utils.js?v=7.1.2"></script>

  <script src="/js/motion.js?v=7.1.2"></script>



  
  


  <script src="/js/affix.js?v=7.1.2"></script>

  <script src="/js/schemes/pisces.js?v=7.1.2"></script>




  
  <script src="/js/scrollspy.js?v=7.1.2"></script>
<script src="/js/post-details.js?v=7.1.2"></script>



  


  <script src="/js/next-boot.js?v=7.1.2"></script>


  

  

  

  


  


  




  

  

  

  

  

  

  

  

  

  

  

  

  

  

</body>
</html>
